<html>
<div>
    <canvas id="myCanvas" 
    style="border:1px solid #000000;">
    </canvas>
</div>
<script src="obj.js" ></script>
<script src="loadobj.js" ></script>
<script src="algorithm.js" ></script>


<script>
  let vec1 = new Vec([1,2,3]);
  let m1 = new Matrix([[1,2,3],[4,5,6]]);

  let vec3 = m1.multi(vec1);
  console.log(vec3.arr);

</script>
<script>
    // console.log(obj_str);
    loader = new Loader(obj_str);
    let light_dir = [1,1,1];
    let eye = [2,1,3];
    let position = [0,0,0];
    let up = [0,1,0];
    let width = 800;
    let height = 800;
    let canvas = document.getElementById("myCanvas");
    canvas.height = height;
    canvas.width = width;
    var ctx= canvas.getContext("2d");
    let imgdata = ctx.createImageData(width, height);
    let zbuffer = [];
    for(let i=0;i<width*height;i++){
        zbuffer.push(-1000000);
    }
    function dot(v1,v2){
        return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
    }

    function modelView(){
        let y_vec = new Vec(up);
        y_vec = y_vec.normal();
        let eye_vec = new Vec(eye);
        let position_vec = new Vec(position);
        let z_vec = eye_vec.sub(position_vec);
        z_vec = z_vec.normal();
        let x_vec = cross_vec(y_vec,z_vec);
        x_vec = x_vec.normal();
        y_vec = cross_vec(z_vec,x_vec);
        let r =  new Matrix(
            [
                [x_vec.arr[0],x_vec.arr[1],x_vec.arr[2],0],
                [y_vec.arr[0],y_vec.arr[1],y_vec.arr[2],0],
                [z_vec.arr[0],z_vec.arr[1],z_vec.arr[2],0],
                [0,0,0,1],
            ]
        );
        let translate = new Matrix(
            [1,0,0,-eye[0]],
            [0,1,0,-eye[1]],
            [0,0,1,-eye[2]],
            [0,0,0,1]
        );
        return r.multi(translate);
    }
    function projection(c){
        return new Matrix(
            [
                [1,0,0,0],
                [0,1,0,0],
                [0,0,1,0],
                [0,0,-1/c,0]
            ]
        );
    }
    function draw_line(bg,ed){
        ctx.moveTo(bg[0],bg[1]);
        ctx.lineTo(ed[0],ed[1]);
    }
    function triangle(tris,zbuffer,color){
        let min_x = 1000000;
        let max_x = -1000000;
        let min_y = 1000000;
        let max_y = -1000000;
        // let color = Math.random()*255;
        for(let i=0;i<3;i++){
            let x = parseInt(tris[i].arr[0]);
            let y = parseInt(tris[i].arr[1]);
            if(min_x > x){
                min_x = x;
            }
            if(max_x < x){
                max_x = x;
            }
            if(min_y > y){
                min_y = y;
            }
            if(max_y < y){
                max_y = y;
            }
        }
        for(let x=min_x;x<=max_x;x++){
            for(let y=min_y;y<=max_y;y++){
                // console.log(x+" "+y);
                let center = binary_center(tris,new Vec([x,y,1]));
                if(center.arr[0] <= 0 || center.arr[1] <= 0 || center.arr[2] <= 0){
                    continue;
                }
                let z = center.arr[0] * tris[0].arr[2] + center.arr[1] * tris[1].arr[2] + center.arr[2] * tris[2].arr[2]; 
                // console.log(z);
                let index = x + y * width;
                if(zbuffer[index] < z){
                    zbuffer[index] = z;
                    let idx = 4*index;
                    imgdata.data[idx] =  color*255;
                    imgdata.data[idx+1] =  color*255;
                    imgdata.data[idx+2] =  color*255;
                    imgdata.data[idx+3] = 255;
                }

            }
        }
    }
    function sub(v1,v2){
        ret = []
        for(let i=0;i<v1.length;i++){
            ret.push(v1[i]-v2[i]);
        }
        return ret;
    }

    function cross2(v1,v2){
        return v1[0] * v2[1] - v1[1] * v2[0]; 
    }

    function cross3(v1,v2){
        return [v1[1]*v2[2]-v1[2]*v2[1],v1[0]*v2[2]-v1[2]*v2[0],v1[0]*v2[1]-v1[1]*v2[0]];
    }

    function cross_vec(vec1,vec2){
        if(vec1.arr.length == 2){
            return cross2(vec1.arr,vec2.arr);
        }else if(vec1.arr.length == 3){
            return new Vec(cross3(vec1.arr,vec2.arr));
        }
    }

    function  binary_center(tri,p){
        let ac = tri[0].sub(tri[2]).proj(2);
        let bc = tri[1].sub(tri[2]).proj(2);
        let pc = p.sub(tri[2]).proj(2);
        let alpha = cross_vec(pc,bc)/cross_vec(ac,bc);
        let beta = cross_vec(pc,ac)/cross_vec(bc,ac);
        let gamma = 1 -alpha - beta;
        return new Vec([alpha,beta,gamma]);
    }

    function length(v){
        return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
    }

    function norm(v){
        let l = length(v);
        return [v[0]/l,v[1]/l,v[2]/l];
    }


    function view(v){
        return [width-(v[0]+1)*width/2,height-(v[1]+1)*height/2];
    }
    let count = 0;
    for(let face of loader.faces){
        count += 1;
        let screens = [];
        let world = [];
        for(let i=0;i<3;i++){
            let v = loader.vertexs[face[i]];
            let screen_coord = view([v[0],v[1]]);
            screen_coord.push(v[2]);
            world.push(new Vec(v));
            screens.push(new Vec(screen_coord));
        }
        // console.log(world);
        let normal = cross_vec(world[1].sub(world[0]),world[2].sub(world[1]));
        // console.log(normal);
        normal = normal.normal();
        // console.log(normal);
        let light_vec = new Vec(light_dir);
        light_vec = light_vec.normal();
        let color = light_vec.dot(normal);
        console.log(color);
        // if(color > 0){
        triangle(screens,zbuffer,Math.abs(color));
        // }
        // break;
        // draw_line(tri[0],tri[1]);
        // draw_line(tri[1],tri[2]);
        // draw_line(tri[2],tri[0]);
    }
    // console.log(imgdata.data);
    ctx.putImageData(imgdata, 0, 0);
    // ctx.stroke();
</script>

</html>
